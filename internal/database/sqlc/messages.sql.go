// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: messages.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO notifications.messages (
    id,
    content,
    recipient_phone_number,
    status
) VALUES (
    $1, $2, $3, 'pending'
)
RETURNING id
`

type CreateMessageParams struct {
	ID                   uuid.UUID `json:"id"`
	Content              string    `json:"content"`
	RecipientPhoneNumber string    `json:"recipient_phone_number"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createMessage, arg.ID, arg.Content, arg.RecipientPhoneNumber)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getAllSentMessages = `-- name: GetAllSentMessages :many
SELECT
    id,
    content,
    recipient_phone_number,
    status,
    external_message_id,
    created_at,
    updated_at
FROM notifications.messages
WHERE status = 'sent'
ORDER BY updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAllSentMessagesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllSentMessagesRow struct {
	ID                   uuid.UUID                  `json:"id"`
	Content              string                     `json:"content"`
	RecipientPhoneNumber string                     `json:"recipient_phone_number"`
	Status               NotificationsMessageStatus `json:"status"`
	ExternalMessageID    pgtype.Text                `json:"external_message_id"`
	CreatedAt            time.Time                  `json:"created_at"`
	UpdatedAt            time.Time                  `json:"updated_at"`
}

func (q *Queries) GetAllSentMessages(ctx context.Context, arg GetAllSentMessagesParams) ([]GetAllSentMessagesRow, error) {
	rows, err := q.db.Query(ctx, getAllSentMessages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllSentMessagesRow{}
	for rows.Next() {
		var i GetAllSentMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.RecipientPhoneNumber,
			&i.Status,
			&i.ExternalMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingMessages = `-- name: GetPendingMessages :many
SELECT
    id,
    content,
    recipient_phone_number,
    status,
    external_message_id,
    created_at,
    updated_at
FROM notifications.messages
WHERE status = 'pending'
ORDER BY created_at ASC
LIMIT $1
`

type GetPendingMessagesRow struct {
	ID                   uuid.UUID                  `json:"id"`
	Content              string                     `json:"content"`
	RecipientPhoneNumber string                     `json:"recipient_phone_number"`
	Status               NotificationsMessageStatus `json:"status"`
	ExternalMessageID    pgtype.Text                `json:"external_message_id"`
	CreatedAt            time.Time                  `json:"created_at"`
	UpdatedAt            time.Time                  `json:"updated_at"`
}

func (q *Queries) GetPendingMessages(ctx context.Context, limit int32) ([]GetPendingMessagesRow, error) {
	rows, err := q.db.Query(ctx, getPendingMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingMessagesRow{}
	for rows.Next() {
		var i GetPendingMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.RecipientPhoneNumber,
			&i.Status,
			&i.ExternalMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessageStatus = `-- name: UpdateMessageStatus :exec
UPDATE notifications.messages
SET
    status = $3,
    external_message_id = $1,
    updated_at = NOW(),
    last_failure_reason = $4
WHERE id = $2
`

type UpdateMessageStatusParams struct {
	ExternalMessageID pgtype.Text                `json:"external_message_id"`
	ID                uuid.UUID                  `json:"id"`
	Status            NotificationsMessageStatus `json:"status"`
	LastFailureReason pgtype.Text                `json:"last_failure_reason"`
}

func (q *Queries) UpdateMessageStatus(ctx context.Context, arg UpdateMessageStatusParams) error {
	_, err := q.db.Exec(ctx, updateMessageStatus,
		arg.ExternalMessageID,
		arg.ID,
		arg.Status,
		arg.LastFailureReason,
	)
	return err
}
